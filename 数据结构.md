# 数据结构

## 定义

数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的数据结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。

数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的存储结构。

数据的3个层次；再通过抽象，舍弃数据元素的具体内容，就得到逻辑结构。类似地，通过分解将处理要求划分成各种功能，再通过抽象舍弃实现细节，就得到运算的定义。上述两个方面的结合可以将问题变换为数据结构。这是一个从具体（即具体问题）到抽象（即数据结构）的过程。然后，通过增加对实现细节的考虑进一步得到存储结构和实现运算，从而完成设计任务。这是一个从抽象（即数据结构）到具体（即具体实现）的过程。

数据结构的研究内容是构造复杂软件系统的基础，它的核心技术是分解与抽象。通过分解可以划分出数据的3个层次；再通过抽象，舍弃数据元素的具体内容，就得到逻辑结构。类似地，通过分解将处理要求划分成各种功能，再通过抽象舍弃实现细节，就得到运算的定义。上述两个方面的结合可以将问题变换为数据结构。这是一个从具体（即具体问题）到抽象（即数据结构）的过程。然后，通过增加对实现细节的考虑进一步得到存储结构和实现运算，从而完成设计任务。这是一个从抽象（即数据结构）到具体（即具体实现）的过程。

## 分类

数据结构主要分为线性结构和非线性结构

线性结构主要包括：数组，队列，链表，栈

非线性结构主要包括：二维数组，多维数组，广义表，树结构，图结构



### 稀疏数组

![image-20210825170025271](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210825170025271.png)

### 将一个稀疏数组压缩后再解压过程：

```java
package main.java.com.youxin.sparsearray;

public class SparseArray {
    public static void main(String[] args) {
        //定义稀疏数组（棋盘）
        int sparse[][] = new int[11][11];
        //0代表没有棋子，1代表白棋，2代表黑棋
        sparse[1][2] = 1;
        sparse[2][3] = 2;
        sparse[10][10] = 1;
        //输出稀疏矩阵
        System.out.println("原本棋盘为：");
        for (int row[] : sparse){
            for(int item : row){
                System.out.printf("%d\t",item);
            }
            System.out.println();
        }


        //计算棋子数
        int count = 0;
        for (int row[] : sparse){
            for(int item : row){
                if (item != 0){
                    count ++;
                }
            }
        }

        //定义压缩数组
        int compressArray[][] = new int[count+1][3];
        compressArray[0][0] = sparse.length;
        compressArray[0][1] = sparse[0].length;
        compressArray[0][2] = count;

        //给压缩数组赋值
        int rows = 0;//用于记录第几个非零数据
        for (int i=0; i < sparse.length;i++){
            for (int j=0; j  < sparse[0].length; j++){
                if (sparse[i][j] != 0){
                    rows ++;
                    compressArray[rows][0] = i;
                    compressArray[rows][1] = j;
                    compressArray[rows][2] = sparse[i][j];
                }
            }
        }

        //输出压缩数组
        System.out.println("缩后的棋盘为：");
        for (int row[]:compressArray
             ) {
            System.out.printf("%d\t%d\t%d\n",row[0],row[1],row[2]);
        }

        //解压稀疏矩阵
        int sparseArray[][] = new int[compressArray[0][0]][compressArray[0][1]];
        //放入压缩的值
        for (int i =1;i < compressArray.length;i++){
            sparseArray[compressArray[i][0]][compressArray[i][1]] = compressArray[i][2];
        }

        //输出解压后的稀疏矩阵
        System.out.println("解压后的棋盘为：");
        for (int row[] : sparseArray){
            for(int item : row){
                System.out.printf("%d\t",item);
            }
            System.out.println();
        }

    }
}

```

得到结果：

![image-20210826144044659](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210826144044659.png)

不足分析，由于要求的是将当前棋盘保存下来再进行恢复，但由于时间问题，没有进行io操作，没有吧棋盘保存到文件中去，并且其中灵活性不高，这点是需要改进的。

### 数组模拟队列

![image-20210826144457341](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210826144457341.png)

```java
package main.java.com.youxin.queue;

public class ArrayQueueDemo {
    public static void main(String[] args) {
        //创建一个队列
        ArrayQueue arrayQueue = new ArrayQueue(4);
        arrayQueue.addQueue(1);
        arrayQueue.addQueue(2);
        arrayQueue.showQueue();
        System.out.println();
        System.out.println(arrayQueue.getQueue());
        System.out.println(arrayQueue.headQueue());
        arrayQueue.showQueue();
    }
}
class ArrayQueue{
    private int maxSize;//表示队列最大容量
    private int front;//队列头
    private int rear;//队列尾
    private int[] arr;//数组，模拟队列

    //创建队列构造器
    public ArrayQueue(int maxSize){
        this.maxSize = maxSize;
        arr = new int[maxSize];
        front = -1;//指向队列头部初始化（指向的是队列头部的前一个位置）
        rear = -1;//指向队列尾部初始化
    }

    //判断队列是否已满
    public boolean isFull(){
        return rear == maxSize -1;
    }

    //判断队列是否为空
    public boolean isEmpty(){
        return front == rear;
    }

    //添加队列数据，入队列
    public void addQueue(int attr){
        //判断队列是否满了
        if (isFull()){
            throw new RuntimeException("队列已满，不能添加~~");
        }else {
            rear++;//将尾指针后移
            arr[rear] = attr;
        }
    }

    //获取队列数据，出队列
    public int getQueue(){
        //判断队列是否为空
        if (isEmpty()){
            throw new RuntimeException("队列为空，不能获取~~");
        }else {
            front++;
            return arr[front];
        }
    }

    //显示队列所有数据
    public void showQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空，不能输出~~");
        }else {
            for (int i=front+1;i < arr.length;i ++){
                System.out.printf("%d\t",arr[i]);
            }
        }
    }

    //显示队列头部
    public int headQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空，不能显示头部~~");
        }else {
            return arr[front+1];
        }
    }
}


```

![image-20210826144543120](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210826144543120.png)

分析：能够用数组模拟一个队列以及队列的基本操作等，但是如果当头部的数据取出后而尾指针指向了最大值时，前面的数据就造成了浪费，如果前面已经有取出的数据，而尾指针指向了最大值时可以再次指向头部直至头指针位置就可以减少空间浪费情况。所以可以用循环队列实现。

### 循环队列

![image-20210826144338254](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210826144338254.png)

```java
package main.java.com.youxin.queue;

public class CircleQueueDemo {
    public static void main(String[] args) {
        //创建一个队列
        CircleQueue queue = new CircleQueue(5);
        queue.addQueue(1);
        queue.showQueue();
        queue.addQueue(2);
        queue.showQueue();
        queue.addQueue(3);
        queue.showQueue();
        queue.addQueue(4);
        queue.showQueue();
        System.out.println("取出队列第一个值："+queue.getQueue());
        queue.showQueue();
        System.out.println("获取队列头指针指向的值："+queue.headQueue());
        queue.addQueue(5);
        queue.showQueue();
    }
}

class CircleQueue{
    private int maxSize;//表示队列最大容量
    //front指向队列的第一个元素，
    private int front;//队列头，初始值为0
    //rear指向队列的最后一个元素
    //队列尾，初始值为0,当尾指针指向最后一个数组元素的时候就不能够再添加了，
    // 因为判断队列满的条件是尾指针加1后与头指针相等，即尾指针与头指针之间有一个空数值。
    private int rear;
    private int[] arr;//数组，模拟队列

    public CircleQueue(int maxSize){
        this.maxSize = maxSize;
        arr = new int[maxSize];
        front = 0;
        rear = 0;
    }

    //判断队列是否已满
    public boolean isFull(){
        return (rear + 1) % maxSize == front;
    }

    //判断队列是否为空
    public boolean isEmpty(){
        return front == rear;
    }

    //添加队列数据，入队列
    public void addQueue(int attr){
        //判断队列是否满了
        if (isFull()){
            throw new RuntimeException("队列已满，不能添加~~");
        }else {
            arr[rear] = attr;
            rear = (rear + 1) % maxSize;
        }
    }

    //获取队列数据，出队列
    public int getQueue(){
        //判断队列是否为空
        if (isEmpty()){
            throw new RuntimeException("队列为空，不能获取~~");
        }else {
            //取出队列头放入临时变量
            //将front后移
            //返回临时变量
            int temp = arr[front];
            front = (front + 1) % maxSize;
            return temp;
        }
    }

    //显示队列所有数据
    public void showQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空，不能输出~~");
        }else {
            System.out.print("输出队列所有值：");
            for (int i=front;i < size()+front;i ++){
                System.out.printf("%d\t",arr[i % maxSize]);
            }
            System.out.println();
        }
    }

    //求出当前队列个数
    public int size(){
        return (rear + maxSize - front) % maxSize;
    }

    //显示队列头部
    public int headQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空，不能显示头部~~");
        }else {
            return arr[front];
        }
    }
}

```

![image-20210826154019734](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210826154019734.png)

至此，完整演示了一个循环队列的生成与队列包含基本方法。



### 链表(Linked List)

小结：

1、链表是以节点的方式来存储。

2、每个节点包括data域，next域：指向下一个节点。

3、链表的各个节点不一定是连续存储。

4、链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定。

#### 单向链表

头节点：不存放具体的数据，作用就是表示单链表头

##### 单链表操作：

```java
package main.java.com.youxin.linkedlist;

public class SingleLinkedListDemo {
    public static void main(String[] args) {
        HeroNode heroNode01 = new HeroNode(1, "林冲", "豹子头");
        HeroNode heroNode02 = new HeroNode(2, "宋江", "及时雨");
        HeroNode heroNode03 = new HeroNode(3, "武松", "行者");
        HeroNode heroNode04 = new HeroNode(4, "鲁智深", "花和尚");
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        singleLinkedList.add(heroNode01);
        singleLinkedList.add(heroNode02);
        singleLinkedList.add(heroNode03);
        singleLinkedList.add(heroNode04);
        singleLinkedList.show();
        //修改武松信息
        singleLinkedList.update(new HeroNode(3,"wusong","打虎英雄"));
        System.out.println("修改后：");
        singleLinkedList.show();
        //删除no为4的信息
        singleLinkedList.delete(4);
        System.out.println("删除后：");
        singleLinkedList.show();
    }
}

class HeroNode {
    //编号
    public int no;
    //名字
    public String name;
    //昵称
    public String nickName;
    //指向下一个节点
    public HeroNode next;

    //构造方法
    public HeroNode(int no, String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;

    }

    //重写toString方法

    @Override
    public String toString() {
        return "[no:" + no + "  name:" + name + "  nickName:" + nickName + "]";
    }
}

//定义SingleLinkedList
class SingleLinkedList{
    //初始化一个头节点，头节点不要动，不会存放数据
    private HeroNode head = new HeroNode(0,"","");

    //添加节点到单向链表
    //当不考虑编号顺序时
    //1、找到当前链表的最后节点
    //2、将最后这个节点的next指向新的节点
    public void add(HeroNode heroNode){
        //因为head节点不能动，因此需要一个辅助遍历temp
        HeroNode temp = head;
        //遍历链表，找到最后
        while (true){
            //当找到链表的最后
            if (temp.next == null){
                break;
            }
            //如果没有找到将temp后移
            temp = temp.next;
        }
        //当退出while循环时，temp指向了链表的最后
        //将最后的节点的next指向新的节点
        temp.next = heroNode;
    }

    //遍历链表
    public void show(){
        //判断链表是否为空
        if (head.next == null){
            throw new RuntimeException("链表为空，不能遍历~~");
        }
        //头指针不能动，需要一个辅助变量来遍历
        HeroNode temp = head.next;
        while (true){
            //判断链表是否到最后
            if (temp == null){
                break;
            }
            //输出节点信息
            System.out.println(temp);
            //将temp后移
            temp = temp.next;
        }
    }

    //修改节点信息，根据no找
    public void update(HeroNode newHeroNode){
        //定义一个辅助变量
        HeroNode temp = head.next;
        //记录是否找到该节点
        boolean flag = false;
        while (true){
            if (temp == null){
                break;//已经遍历完链表都没找到
            }
            if (temp.no == newHeroNode.no){
                //找到
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //根据flag判断是否找到
        if (flag){
            temp.name = newHeroNode.name;
            temp.nickName = newHeroNode.nickName;
        }else {
            System.out.println("没有找到编号为"+newHeroNode.no+"的节点");
        }
    }

    //删除节点信息
    //head不能动，因此需要一个temp辅助节点找到待删除的节点
    //在比较时,是temp.next.no与需要删除节点的no比较
    public void delete(int no){
        HeroNode temp = head;
        //标记是否找到待删除的节点
        boolean flag = false;
        while (true){
            if (temp.next == null){
                //表示已经遍历完了
                break;
            }
            if (temp.next.no == no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //判断flag
        if (flag){
            //可以删除
            temp.next = temp.next.next;
        }else {
            System.out.println("没有找到编号为"+no+"的节点");
        }
    }
}

```

![image-20210826174638269](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210826174638269.png)

单向链表缺点：

1、单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找

2、单向链表不能自我删除，需要靠辅助节点，而双向链表则可以自我删除，所以单链表删除时总是找到temp的下一个节点来删除

#### 双向链表

```java
package main.java.com.youxin.linkedlist;

public class DoubleLinkedListDemo {
    public static void main(String[] args) {
        HeroNode2 heroNode01 = new HeroNode2(1, "林冲", "豹子头");
        HeroNode2 heroNode02 = new HeroNode2(2, "宋江", "及时雨");
        HeroNode2 heroNode03 = new HeroNode2(3, "武松", "行者");
        HeroNode2 heroNode04 = new HeroNode2(4, "鲁智深", "花和尚");
        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
        doubleLinkedList.add(heroNode01);
        doubleLinkedList.add(heroNode02);
        doubleLinkedList.add(heroNode03);
        doubleLinkedList.add(heroNode04);
        doubleLinkedList.show();
        //修改武松信息
        doubleLinkedList.update(new HeroNode2(3,"wusong1","打虎legend"));
        System.out.println("修改后：");
        doubleLinkedList.show();
        //删除no为4的信息
        doubleLinkedList.delete(4);
        doubleLinkedList.delete(3);
        System.out.println("删除后：");
        doubleLinkedList.show();
    }
}

class DoubleLinkedList{
    //初始化一个头节点，头节点不要动，不会存放数据
    private HeroNode2 head = new HeroNode2(0,"","");
    //返回头结点
    public HeroNode2 getHead(){
        return head;
    }

    //遍历双向链表
    //遍历链表
    public void show(){
        //判断链表是否为空
        if (head.next == null){
            throw new RuntimeException("链表为空，不能遍历~~");
        }
        //头指针不能动，需要一个辅助变量来遍历
        HeroNode2 temp = head.next;
        while (true){
            //判断链表是否到最后
            if (temp == null){
                break;
            }
            //输出节点信息
            System.out.println(temp);
            //将temp后移
            temp = temp.next;
        }
    }

    //添加节点到双向链表
    public void add(HeroNode2 heroNode){
        //因为head节点不能动，因此需要一个辅助遍历temp
        HeroNode2 temp = head;
        //遍历链表，找到最后
        while (true){
            //当找到链表的最后
            if (temp.next == null){
                break;
            }
            //如果没有找到将temp后移
            temp = temp.next;
        }
        //当退出while循环时，temp指向了链表的最后
        //将最后的节点的next指向新的节点
        temp.next = heroNode;
        //形成双向链表
        heroNode.pre = temp;
    }

    //修改节点信息，根据no找
    public void update(HeroNode2 newHeroNode){
        //定义一个辅助变量
        HeroNode2 temp = head.next;
        //记录是否找到该节点
        boolean flag = false;
        while (true){
            if (temp == null){
                break;//已经遍历完链表都没找到
            }
            if (temp.no == newHeroNode.no){
                //找到
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //根据flag判断是否找到
        if (flag){
            temp.name = newHeroNode.name;
            temp.nickName = newHeroNode.nickName;
        }else {
            System.out.println("没有找到编号为"+newHeroNode.no+"的节点");
        }
    }

    //删除节点信息
    //对于双向链表可以直接找到要删除的这个节点
    //找到后自我删除即可
    public void delete(int no){
        //判断链表是否为空
        if (head.next == null){
            System.out.println("链表为空！");
        }
        HeroNode2 temp = head.next;
        //标记是否找到待删除的节点
        boolean flag = false;
        while (true){
            if (temp == null){
                //表示已经遍历完了
                break;
            }
            if (temp.no == no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //判断flag
        if (flag){
            //可以删除
            if (temp.next != null) {
                temp.next.pre = temp.pre;
            }
            temp.pre.next = temp.next;
        }else {
            System.out.println("没有找到编号为"+no+"的节点");
        }
    }
}

class HeroNode2 {
    //编号
    public int no;
    //名字
    public String name;
    //昵称
    public String nickName;
    //指向下一个节点
    public HeroNode2 next;
    //指向上一个节点
    public HeroNode2 pre;//默认为null

    //构造方法
    public HeroNode2(int no, String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;

    }

    //重写toString方法
    @Override
    public String toString() {
        return "[no:" + no + "  name:" + name + "  nickName:" + nickName + "]";
    }
}

```

![image-20210826202052909](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210826202052909.png)

### 约瑟夫问题（循环链表）

约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3。

分析：

（1）由于对于每个人只有死和活两种状态，因此可以用布尔型数组标记每个人的状态，可用true表示死，false表示活。

（2）开始时每个人都是活的，所以数组初值全部赋为false。

（3）模拟杀人过程，直到所有人都被杀死为止。

代码实现

```java
package main.java.com.youxin.linkedlist;

public class JosePhu {
    public static void main(String[] args) {
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.add(6);
       	circleSingleLinkedList.show();
        circleSingleLinkedList.outBoy(1,5,6);
    }
}

//创建一个环形单向链表
class CircleSingleLinkedList{
    //创建一个first节点，初始没有编号
    private BoyNode first = null;

    //添加节点
    public void add(int nums){
        if (nums < 1){
            System.out.println("添加节点的数目至少为1！");
        }
        //创建一个辅助指针，帮助构建环形链表
        BoyNode curBoy = null;
        //使用for循环创建环形链表
        for (int i = 1;i <= nums;i++){
            //根据编号，创建节点
            BoyNode boyNode = new BoyNode(i);
            if (i == 1){
                first = boyNode;
                first.setNext(first);
                curBoy = first;
            }
            curBoy.setNext(boyNode);
            boyNode.setNext(first);
            curBoy = boyNode;
        }
    }

    //遍历循环链表
    public void show(){
        //判断链表是否为空
        if (first == null){
            System.out.println("链表为空，不能遍历！");
            return;
        }
        //使用辅助指针完成遍历
        BoyNode curBoy = first;
        while (true){
            System.out.printf("节点编号:%d\t  ",curBoy.getNo());
            if (curBoy.getNext() == first){
                break;
            }
            //curBoy后移
            curBoy = curBoy.getNext();
        }
        System.out.println();
    }

    //计算出圈顺序
    //startNo:表示从第几个人开始报号，countNo:表示报到多少号，nums:表示最初有几个人在圈中
    public void outBoy(int startNo,int countNo,int nums){
        //对输入数据进行校验
        if (first == null || startNo < 1 || countNo > nums){
            throw new RuntimeException("参数有误，需要改正！！");
        }
        //创建辅助指针，帮助出圈
        BoyNode curNode = first;
        //创建的辅助指针事先应该指向环形链表的最后节点
        while (true){
            //表示辅助指针已经指向最后节点
            if (curNode.getNext() == first){
                break;
            }
            curNode = curNode.getNext();
        }
        //报数前，先让first和辅助指针移动startNo-1次
        for (int i = 0; i < startNo - 1; i++){
            first = first.getNext();
            curNode = curNode.getNext();
        }
        //报数时，将first和辅助指针同时移动countNo-1次，然后出圈，直到圈中只有一个节点
        while (true){
            //说明圈中只有一个节点
            if (curNode == first){
                break;
            }
            //移动
            for (int i =0; i < countNo - 1; i++){
                first = first.getNext();
                curNode = curNode.getNext();
            }
            //这是first指向的节点，就是要出圈的节点
            System.out.printf("节点%d出圈！",first.getNo());
            //出圈
            first = first.getNext();
            curNode.setNext(first);
        }
        System.out.printf("最后留在圈中的人的编号为%d\n",first.getNo());
    }
}

//创建一个BoyNode类，表示一个节点
class BoyNode{
    private int no;//节点编号
    private BoyNode next;//指向下一个节点，默认为null

    public BoyNode(int no){
        this.no = no;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public BoyNode getNext() {
        return next;
    }

    public void setNext(BoyNode next) {
        this.next = next;
    }
}

```

结果演示：

![image-20210827113128494](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210827113128494.png)

### 栈（stack）

![栈的模型](https://bkimg.cdn.bcebos.com/pic/8b82b9014a90f603eab7c55f3912b31bb051eda7?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto)

#### 栈的基本应用场景

1)子程序的调用:在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。

2)处理递归调用:和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。

3)表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。

4)二叉树的遍历。

5)图形的深度优先(depth一first)搜索法。

#### 数组模拟栈

```java
package main.java.com.youxin.stack;

public class ArrayStackDemo {
    public static void main(String[] args) {
        //测试
        ArrayStack arrayStack = new ArrayStack(4);
        arrayStack.push(1);
        arrayStack.push(2);
        arrayStack.push(3);
        arrayStack.push(4);
        System.out.println("弹栈:");
        System.out.println(arrayStack.pop());
        System.out.println("显示栈全部数据:");
        arrayStack.show();
    }
}

//定义一个ArrayStack表示栈
class ArrayStack{
    //栈的大小
    private int maxSize;
    //数组模拟栈
    private int[] stack;
    //top表示栈顶，初始化为-1
    private int top = -1;

    public ArrayStack(int maxSize){
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    //栈满
    public boolean isFull(){
        return top == maxSize - 1;
    }

    //栈空
    public boolean isEmpty(){
        return top == -1;
    }

    //压栈
    public void push(int value){
        //判断是否栈满
        if (isFull()){
            System.out.println("栈满，不能压栈！");
        }
        top++;
        stack[top] = value;
    }

    //弹栈
    public int pop(){
        //判断栈空
        if (isEmpty()){
            throw new RuntimeException("栈空，不能进行弹栈操作！");
        }
        int temp = stack[top];
        top--;
        return temp;
    }

    //遍历栈
    public void show(){
        if (isEmpty()){
            throw new RuntimeException("栈空，没有数据！");
        }
        //从栈顶开始遍历
        for (int i = top; i >= 0; i--){
            System.out.printf("stack[%d] = %d\n",i,stack[i]);
        }
    }
}

```

结果显示：

![image-20210827155757207](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210827155757207.png)

#### 栈实现简单计算器

```java
package main.java.com.youxin.stack;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Calculator {
    public static void main(String[] args) {
        //完成表达式
        String expression = "700-200*3+6";
        //创建两个栈，一个数栈，一个符号栈
        ArrayStack2 numStack = new ArrayStack2(10);
        ArrayStack2 operStack = new ArrayStack2(10);
        //定义相关变量
        int index = 0;//用于扫描
        int num1 = 0;
        int num2 = 0;
        int oper = 0;
        int result = 0;
        char ch = ' ';

        //这里用正则表达式获取数字和运算符，能够一次获取多位数字
        //定义一个正则表达式获取字符串中的数字
        Pattern pattern = Pattern.compile("\\d+");
        Pattern pattern2 = Pattern.compile("[^0-9]");
        Matcher matcher = pattern.matcher(expression);
        Matcher matcher2 = pattern2.matcher(expression);
        //查找匹配的数字
        while (matcher.find()){
            System.out.println(Integer.parseInt(matcher.group()));
            numStack.push(Integer.parseInt(matcher.group()));
            //每查找到一个数字后面一定是一个运算符，所以对运算符操作
            while (matcher2.find()){
                ch = matcher2.group().charAt(0);
                System.out.println(ch);
                //判断ch是什么
                if (operStack.isOper(ch)){
                    //判断字符栈是否为空
                    if (!operStack.isEmpty()) {
                        //判断符号是否比字符栈的栈顶优先级高
                        if (operStack.priority(ch) < operStack.priority(operStack.getTop())) {
                            //符号比栈顶优先级低
                            num1 = numStack.pop();
                            num2 = numStack.pop();
                            oper = operStack.pop();
                            result = numStack.cal(num1,num2,oper);
                            //把运算结果入数栈
                            numStack.push(result);
                            //将当前操作符号入符号栈
                            operStack.push(ch);
                        }else {
                            //如果当前操作符号大于栈顶的操作符号优先级，则直接入栈
                            operStack.push(ch);
                        }
                    }else {
                        //如果栈为空则直接入栈
                        operStack.push(ch);
                    }
                }
                //每查找到一个运算符，就需要对运算符进行入栈等操作，操作完后继续查找数字
                break;
            }
        }

        //将运算字符串的字符一个一个拿出来进行比较：当运算两位数的时候就会出问题
        //开始循环
       /* while (true){
            //依次得到每一个字符
            ch = expression.substring(index,index+1).charAt(0);
            //判断ch是什么
            if (operStack.isOper(ch)){
                //判断字符栈是否为空
                if (!operStack.isEmpty()) {
                    //判断符号是否比字符栈的栈顶优先级高
                    if (operStack.priority(ch) < operStack.priority(operStack.getTop())) {
                        //符号比栈顶优先级低
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        result = numStack.cal(num1,num2,oper);
                        //把运算结果入数栈
                        numStack.push(result);
                        //将当前操作符号入符号栈
                        operStack.push(ch);
                    }else {
                        //如果当前操作符号大于栈顶的操作符号优先级，则直接入栈
                        operStack.push(ch);
                    }
                }else {
                    //如果栈为空则直接入栈
                    operStack.push(ch);
                }
            }else {
                //如果是数，则直接入到数栈中
                numStack.push(ch - '0');
            }
            //让index + 1,并判断是否扫描到字符串最后
            index++;
            if (index >= expression.length()){
                break;
            }
        }*/

        System.out.println("数栈：");
        numStack.show();
        System.out.println("字符栈：");
        operStack.show();

        //当表达式扫描完毕，就顺序地从数栈和符号栈中弹出相应的数和符号进行运算
        while (true){
            //这里在进行最后的加减运算的时候会出问题，因为是栈先进后出的原因，得到的数字和运算符都是倒序的，而加减运算是要按顺序运算的，
            //所以按以下方法会变成倒序运算，如果前面存在减法得到的就不是真正的结果了，
            //这里只是本人图方便，所以直接弹栈操作，如果有兴趣可以将弹栈的数存入数组中再进行运算便可得到正确的运算结果。
            //如果符号栈为空，则表示运算完毕
            if (operStack.isEmpty()){
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            result = numStack.cal(num1,num2,oper);
            //把运算结果入栈
            numStack.push(result);
            //将当前操作符号入符号栈
        }
        System.out.printf("表达式%s的运算结果为%d\n",expression,numStack.pop());

    }


}

//定义一个ArrayStack2表示栈
class ArrayStack2{
    //栈的大小
    private int maxSize;
    //数组模拟栈
    private int[] stack;
    //top表示栈顶，初始化为-1
    private int top = -1;

    public ArrayStack2(int maxSize){
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    //栈满
    public boolean isFull(){
        return top == maxSize - 1;
    }

    //获取栈顶元素，但是不弹栈
    public int getTop(){
        return stack[top];
    }

    //栈空
    public boolean isEmpty(){
        return top == -1;
    }

    //压栈
    public void push(int value){
        //判断是否栈满
        if (isFull()){
            System.out.println("栈满，不能压栈！");
        }
        top++;
        stack[top] = value;
    }

    //弹栈
    public int pop(){
        //判断栈空
        if (isEmpty()){
            throw new RuntimeException("栈空，不能进行弹栈操作！");
        }
        int temp = stack[top];
        top--;
        return temp;
    }

    //遍历栈
    public void show(){
        if (isEmpty()){
            throw new RuntimeException("栈空，没有数据！");
        }
        //从栈顶开始遍历
        for (int i = top; i >= 0; i--){
            System.out.printf("stack[%d] = %d\n",i,stack[i]);
        }
    }

    //返回运算符的优先级，优先级越高，数字越大
    public int priority(int oper){
        if (oper == '*' || oper == '/'){
            return 1;
        }else if (oper == '+' || oper == '-'){
            return 0;
        }else
            return -1;
    }

    //判断是否是一个运算符
    public boolean isOper(char val){
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    //计算
    public int cal(int num1,int num2,int oper){
        //储存运算结果
        int result = 0;
        switch (oper){
            case '+':
                result = num1 + num2;
                break;
            case '-':
                result = num2 - num1;
                break;
            case  '*':
                result = num1 * num2;
                break;
            case '/':
                result = num2 / num1;
                break;
        }
        return result;
    }
}
```

结果：

![image-20210827155908040](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210827155908040.png)

##### 前缀表达式

从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素和次顶元素），并将结果入栈;重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果

例如: (3+4)×5-6对应的前缀表达式就是-×+3456,针对前缀表达式求值步骤如下

1)从右至左扫描，将6、5、4、3压入堆栈

2)遇到+运算符，因此弹出3和4(3为栈顶元素，4为次顶元素），计算出3+4的值，得7,再将7入栈

3)接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈4)最后是-运算符，计算出35-6的值，即29，由此得出最终结果

##### 中缀表达式

1)中缀表达式就是常见的运算表达式，如(3+4)×5-6

2）中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作(前面我们讲的案例

就能看的这个问题)，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式.)

##### 后缀表达式（逆波兰表达式）

1）后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后

2）举例说明:(3+4)×5-6对应的后缀表达式就是34+5 ×6-

![image-20210827172816553](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210827172816553.png)

后缀表达式的计算机求值

从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素和栈顶元素)，并将结果入栈;重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

例如:(3+4)×5-6对应的前缀表达式就是34+5×6-,针对后缀表达式求值步骤如下:

1)从左至右扫描，将3和4压入堆栈;

2)遇到+运算符，因此弹出4和3(4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈;

3)将5入栈;

4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈;

5)将6入栈;

6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果

#### 计算机用后缀表达式改进

```java

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class PolandNotation {
    public static void main(String[] args) {
        //先定义逆波兰表达式
        //（3+4）*5-6 => 3 4 + 5 * 6 -
        // 12 + 3 / (2 + 1)
//        String suffixExpression = "3 4 + 5 * 6 -";
        String suffixExpression = "3 2 1 + / 12 +";
        //将suffixExpression放入到一个ArrayList中
        List<String> list = getList(suffixExpression);
        System.out.println(list);
        System.out.println("结果为:" + calculator(list));


    }

    public static List<String> getList(String expression){
        //使用空格分割
        String[] strings = expression.split(" ");
        ArrayList<String> arrayList = new ArrayList<>();
        //将Strings放入arraylist中
        for (String i : strings) {
            arrayList.add(i);
        }
        return arrayList;
    }

    public static int calculator(List<String> list){
        //创建栈
        Stack<String> stack = new Stack<String>();
        int result = 0;//计算结果
        //判断list中是否为数字
        for (String item : list
             ) {
            //正则表达式判断
            if (item.matches("\\d+")){
                stack.push(item);
            }else if (item.equals("+") || item.equals("-") || item.equals("*") || item.equals("/")) {
                //取出栈顶两个元素
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                switch (item) {
                    case "+":
                        result = num1 + num2;
                        break;
                    case "-":
                        result = num1 - num2;
                        break;
                    case "*":
                        result = num1 * num2;
                        break;
                    case "/":
                        result = num1 / num2;
                        break;
                }
                //将结果放入栈顶
                stack.push("" + result);
            } else {
                throw new RuntimeException("运算符错误");
            }
        }
        return result;
    }
}

```

结果：

![image-20210830113841708](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210830113841708.png)

## 递归

### 递归需要遵循的重要原则

1)执行一个方法时，就创建一个新的受保护的独立空间(栈空间)

2)方法的局部变量是独立的，不会相互影响，比如n变量

3)如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.

4)递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了

5)当一个方法执行完毕,I或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕

#### 迷宫回溯问题

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png) |

 

```java
package main.java.com.youxin.recursion;

public class Maze {
    public static void main(String[] args) {
        /*
        * 规定：
        * map表示地图；
        * 地图未走过用0表示；
        * 地图边界用一走过；
        * 地图走过用2表示；
        * 3表示该点已走过但是不通；
        * 走迷宫时，需要一个策略，即下->右->上->左
        * */
        //初始化迷宫
        int map[][] = getMap(9,8);
        //设置迷宫边框：第一列最后一列，第一行最后一行都为1
        //设置第一行和最后一行为1
        for (int i = 0; i < map.length; i++){
            if (i == 0 || i == map.length-1){
                for (int j = 0; j < map[0].length; j++){
                    map[i][j] = 1;
                }
            }
        }
        //设置第一列和最后一列为1
        for (int i = 0; i < map[0].length; i++){
            if (i == 0 || i == map[0].length-1){
                for (int j = 0; j < map.length; j++){
                    map[j][i] = 1;
                }
            }
        }

        //设置障碍
        map[3][1] = 1;
        map[3][2] = 1;
        map[2][2] = 1;

        //输出迷宫
        for (int row[]:map
             ) {
            for (int element:row
                 ) {
                System.out.printf("%d\t" , element);
            }
            System.out.println();
        }

        //调用goWay方法
        goWay(map, 1, 1);

        System.out.println();
        //输出新迷宫
        for (int row[]:map
        ) {
            for (int element:row
            ) {
                System.out.printf("%d\t" , element);
            }
            System.out.println();
        }
    }

    //i,j表示从地图的哪个位置开始出发，如果能够走到map[map.length - 2][map[0].length - 2位置，则说明道路已经找到
    public static boolean goWay(int[][] map, int i, int j){
        //如果走到最后则返回true
        if (map[map.length - 2][map[0].length - 2] == 2){
            return true;
        }else if (map[i][j] == 0){
            //如果当前点没走过，则假定该点能够走，置为2
            map[i][j] = 2;
            //向下走
            if (goWay(map, i + 1, j)){
                return true;
            }else if (goWay(map, i, j+1)){//向右走
                return true;
            }else if (goWay(map, i-1, j)){//向上走
                return true;
            } else if (goWay(map, i, j - 1)) {//向左走
                return true;
            }else {
                //说明该点是死路走不通
                map[i][j] = 3;
                return false;
            }

        }else
            //如果map[i][j] != 0 ,可能是1，2，3
            return false;
    }

    //获取迷宫大小
    public static int[][] getMap(int i, int j){
        return new int[i][j];
    }
}

```

输出：

![image-20210914184804196](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210914184804196.png)

#### 八皇后问题

1)第一个皇后先放第一行第一列

2)第二个皇后放在第二行第一列、然后判断是否oK，如果不oK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适

3继续第三个皇后，还是第一列、第二.列.….直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解

4)当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.

5)然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤

**说明**:理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题.arr[8]={0 ,4,7,5,2,6,1,3}//对应arr下标表示第几行，即第几个皇后，arr[i] =val , val表示第i+1个皇后，放在第i+1行的第val+1列

```java
package main.java.com.youxin.recursion;

public class Queen8 {

    //代表皇后个数
    int queenSize = 8;
    //定义一维数组且用一维数组的下标表示棋盘的行，value表示棋盘中的列
    int[] array = new int[queenSize];
    //记录所有解个数
    private static int number = 0;


    public static void main(String[] args) {
        Queen8 queen8 = new Queen8();
        queen8.check(0);
        System.out.println("一共有"+number+"种解法;其中数组下标代表行，元素值代表列");

    }

    //输出皇后位置数组
    private   void print(){
        for (int elem : array
             ) {
            //这里elem + 1操作是为了看起来更加方便且配合下标,实际上行数和列数都应该减1
            System.out.printf("%d\t", elem + 1);
        }
        System.out.println();
    }

    /**
     * 判断当前皇后是否与前面已经放置的皇后冲突
     * @param queenNumber 表示第n个皇后
     * @return
     */
    private boolean isClash(int queenNumber){
        /*
        * 说明：
        * 1、array[i] == array[queenNumber]表示判断皇后是否在同一列
        * 2、Math.abs(queenNumber - i) == Math.abs(array[queenNumber] - array[i])判断皇后是否在同一条斜线上；
        * 其会对当前皇后的位置减去前面每一个皇后的位置进行判断是否在同一条斜线上。
        * 3、因为是每一层都会换一个皇后，而又是逐层向下，所以没有必要去对是否在同一行进行判断。
        * */
        for (int i = 0; i < queenNumber; i++){
            if (array[i] == array[queenNumber] || Math.abs(queenNumber - i) == Math.abs(array[queenNumber] - array[i]))
                return false;
        }
        return true;
    }

    //放置皇后
    /**
     * @author youxin
     * @date 2021-09-15 17:07
     * @param queenNumber
     * @return void
     * @throws
     * @since
     */
    private void check(int queenNumber){
        if (8 == queenNumber){
            number++;
            print();
            return;
        }
        //依次放入皇后
        for (int i = 0; i < queenSize; i++){
            //先把当前的皇后放入到该行的第一列
            array[queenNumber] = i;
            //判断当前放置的第queenNumber个皇后时，是否冲突
            if (isClash(queenNumber)){
                //如果不冲突，即可放置并开始递归
                check(queenNumber + 1);
            }
            //如果冲突，则不放置
        }
    }


}

```

![image-20210915161349406](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210915161349406.png)

## 排序算法

**排序也称排序算法**

(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。

**排序的分类:**

1)内部排序:指将需要处理的所有数据都加载到内部存储器中进行排序。

2)外部排序法:数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。

![image-20210915173555420](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210915173555420.png)

### 时间频度

时间频度:一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。

### 算法的时间复杂度

​    1.一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/ f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O( f(n))，称O( f(n)）为算法的渐进时间复杂度，简称时间复杂度。

2) T(n)不同，但时间复杂度可能相同。如: T(n)=n^2^+7n+6与T(n)=3n^2^+2n+2它i们的T(n)不同，但时间复杂度相同，都为O(n^2^)。

3) 计算时间复杂度的方法:

   用常数1代替运行时间中的所有加法常数T(n)=n^2^+7n+6 => T(n)=n^2^+7n+1

   修改后的运行次数函数中，只保留最高阶项T(n)=n^2^+7n+1=>T(n)= n^2^

   去除最高阶项的系数T(n)= n^2^=> T(n)= n^2^=> O(n^2^)

#### 常见的时间复杂度

1、常数阶O(1)

```java
int a = 100;
int b = 10000;
i++;
b++;
sout(a,b)
```

2、对数阶O(log~2~n)

```java
if(i < n){
    i = i * 2;
}
```

3、线性阶O(n)

```java
for(int i = 1; i < n; i++){
    count++;
}
```

4、线性对数阶O(nlog~2~n)

```java
for(int i = 1; i < n; i++){
    j = 1;
    if(j < n){
        j = j * 2;
    }
}
```

5、平方阶O(n^2^)

```java
for(int i = 1; i < n; i ++){
    for(int j = 1; j < n; j++){
        conut++
    }
}
```

6、立方阶O(n^3^)

7、K次方阶O(n^k^)

8、指数阶O(2^n^)

说明：

常见的算法时间复杂度有小到大依次为：O(1)<O(log~2~n)<O(n)<O(nlog~2~n)<O(n^2^)<O(n^3^)<O(n^k^)<O(2^n^)，随着问题规模N的不断增大，时间复杂度也不断增大，算法的执行效率越低

应该尽量避免使用指数阶的算法

### 平均时间复杂度和最坏时间复杂度

1)平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。

2)最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是:最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。

3)平均时间复杂度和最坏时间复杂度是否一致，和算法有关。

![排序](C:\Users\admin\Desktop\排序.png)

### 选择排序

选择排序是从欲排序的数据中，按指定的规则选出某一元素，在依照规定交换位置后达到排序的目的

#### 选择排序思想

选择排序(select sorting)也是一种简单的排序方法。它的基本思想是:第一次从arr[o]~ arr[n-1]中选取最小值，与arr[o]交换，第二次从arr[1] ~ arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2] ~ arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1] ~ arr[n-1]中选取最小值，与arr[i-1]交换，…，第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。

#### 思路

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

![图1 选择排序（最小值）实例](https://bkimg.cdn.bcebos.com/pic/5bafa40f4bfbfbedab646a7c09b9e036afc37931b1d5?x-bce-process=image/resize,m_lfit,w_1280,limit_1/format,f_auto)

```java
package main.java.com.youxin.sort;

/**
 * @author youxin
 * @program datas_tructure-algorithm
 * @description 选择排序算法
 * @date 2021-09-16 17:18
 */
public class SelectSort {
    public static void main(String[] args) {
        int[] array = {11,2,3,-1,-100};
        SelectSort selectSort = new SelectSort();
        selectSort.selectSort(array);
    }

    /**
     * @author youxin
     * @date 2021-09-16 17:21
     * @param arr 需要排序的数组
     * @return void
     * @throws
     * @since
     */
    private void selectSort(int[] arr){
        //记录最小值
        int min;
        //记录最小值下标
        int minIndex;
        for (int i = 0; i < arr.length; i++){
            //改变最小值的指向,默认为数组第一个元素
            min = arr[i];
            minIndex = i;
            for (int j = i + 1; j < arr.length; j++){
                if (min > arr[j]){
                    min = arr[j];
                    minIndex = j;
                }
            }
            //依次将第一个元素与最小的元素交换
            arr[minIndex] = arr[i];
            arr[i] = min;
        }
        //输出数组
        for (int elem: arr
             ) {
            System.out.printf("%d\t",elem);
        }
    }
}

```

![image-20210916174127661](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210916174127661.png)

### 插入排序

插入排序是对欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的

#### 基本思想

插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。拿在左手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌  。

插入排序是指在待排序的元素中，假设前面n-1(其中n>=2)个数已经是排好顺序的，现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序。

#### 稳定性分析

如果待排序的序列中存在两个或两个以上具有相同关键词的数据，排序后这些数据的相对次序保持不变，即它们的位置保持不变，通俗地讲，就是两个相同的数的相对顺序不会发生改变，则该算法是稳定的；如果排序后，数据的相对次序发生了变化，则该算法是不稳定的。关键词相同的数据元素将保持原有位置不变，所以该算法是稳定的。

![image-20210917101716580](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210917101716580.png)

```java
package main.java.com.youxin.sort;

import java.util.Arrays;

/**
 * @author youxin
 * @program datas_tructure-algorithm
 * @description 插入排序算法
 * @date 2021-09-17 10:49
 */
public class InsertSort {
    public static void main(String[] args) {
        int[] array = new int[]{11,2,1,44,3};
        InsertSort insertSort = new InsertSort();
        insertSort.insertSort(array);
    }

    /**
     * @author youxin
     * @date 2021-09-17 11:02
     * @param arr 需要排序的数组
     * @return void
     * @throws
     * @since
     */
    private void insertSort(int[] arr){
        for (int i = 1; i < arr.length; i++){
            //定义待插入的数
            int insertVal = arr[i];
            //arr[i]这个数前一个数的下标
            int insertIndex = i - 1;
            /*
            * insertIndex >= 0保证找插入位置的时候不越界
            * insertVal < arr[insertIndex]待插入的值，还没有找到插入的位置，直到退出循环才表示已经找到
            * insertIndex--需要将下标前移
            * */
            while (insertIndex >= 0 && insertVal < arr[insertIndex]){
                arr[insertIndex + 1] = arr[insertIndex];
                insertIndex--;
            }
            //当退出while循环时，说明插入的位置已经找到，insertIndex + 1
            arr[insertIndex + 1] = insertVal;
            System.out.println("第"+i+"次调用排序结果:");
            System.out.println(Arrays.toString(arr));
        }
    }
}

```

![image-20210917112652102](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210917112652102.png)

### 希尔排序

希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序江它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。

![img](https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161128110416068-1421707828.png)

#### 基本思想

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序;随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止

#### 代码（交换式）

```
package main.java.com.youxin.sort;

import java.util.Arrays;

/**
 * @author youxin
 * @program datas_tructure-algorithm
 * @description 希尔排序算法
 * @date 2021-09-17 14:47
 */
public class ShellSort {
    public static void main(String[] args) {
        int[] array = new int[]{9,8,4,1,5,6,7,3,2,0};
        ShellSort ss = new ShellSort();
        ss.shellSort(array);
    }

    /**
     * @author youxin
     * @date 2021-09-17 14:48
     * @param arr 需要排序的数组
     * @return void
     * @throws
     * @since
     */
    private void shellSort(int[] arr){
        System.out.println("原数组:" + Arrays.toString(arr));
        //定义临时变量
        int temp = 0;
        //记录轮数
        int count = 0;
        for (int gap = arr.length / 2; gap > 0; gap /= 2){
            for (int i = gap; i < arr.length; i++){
                //遍历各组中所有元素（共有gap组）步长gap
                for (int j = i - gap;j >= 0; j = j - gap){
                    //如果每组中的当前元素大于组中后面的元素，说明交换
                    if (arr[j] > arr[j + gap]){
                        temp = arr[j];
                        arr[j] = arr[j + gap];
                        arr[j + gap] = temp;
                    }
                }

            }
            System.out.println("这是第" + ++count + "轮，此步分为" + gap + "组，这步完成后数组为:" + Arrays.toString(arr));
        }
    }
}

```

![image-20210917154208804](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210917154208804.png)

上面的交换式，每次都需要与前一个比较位置并且交换位置，非常的麻烦和耗时间，所以用直接插入的方式可以大大减少时间。

#### 位移式

```java
    //移位式希尔排序
    private void shellSort2(int[] arr){
        for (int gap = arr.length / 2; gap > 0; gap /= 2){
            for (int i = gap; i < arr.length; i++){
                //记录交换的下标
                int insertIndex = i;
                //记录交换的值
                int insertVal = arr[i];
                if (arr[insertIndex] < arr[insertIndex - gap]){
                    while (insertIndex - gap >= 0 && arr[insertIndex] < arr[insertIndex - gap]){
                        //移动
                        arr[insertIndex] = arr[insertIndex - gap];
                        insertIndex -= gap;
                    }
                    //当退出while循环后，就给insertVal找到插入的位置
                    arr[insertIndex] = insertVal;
                }
            }
        }
        System.out.println(Arrays.toString(arr));
    }
```

### 快速排序

![img](https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif)

如下图所示,假设最开始的基准数据为数组第一个元素23,则首先用一个临时变量去存储基准数据,即tmp=23;然后分别从数组的两端扫描数组，设两个指示标志:low指向起始位置，high指向末尾.

![这里写图片描述](https://img-blog.csdn.net/20180910121224126?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

   首先从后半部分开始，如果扫描到的值大于基准数据就让high减1,如果发现有元素比该基准数据的值小(如上图中18<=tmp)，就将high位置的值赋值给low位置 ,结果如下:

![这里写图片描述](https://img-blog.csdn.net/20180910121350322?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

然后开始从前往后扫描,如果扫描到的值小于基准数据就让low加1,如果发现有元素大于基准数据的值(如上图46=>tmp)，就再将low位置的值赋值给high位置的值,指针移动并且数据交换后的结果如下:

![这里写图片描述](https://img-blog.csdn.net/20180910121503615?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

然后再开始从后向前扫描,原理同上,发现上图11<=tmp,则将low位置的值赋值给high位置的值 ,结果如下:

![这里写图片描述](https://img-blog.csdn.net/20180910121538339?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

然后再开始从前往后遍历,直到low=high结束循环,此时low或high的下标就是基准数据23在该数组中的正确索引位置.如下图所示.

![这里写图片描述](https://img-blog.csdn.net/20180910121618344?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

  这样一遍走下来,可以很清楚的知道,其实快速排序的本质就是把基准数大的都放在基准数的右边,把比基准数小的放在基准数的左边,这样就找到了该数据在数组中的正确位置.
  以后采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了。

#### 排序流程

快速排序算法通过多次比较和交换来实现排序，其排序流程如下： 

(1)首先设定一个分界值，通过该分界值将数组分成左右两部分。 

(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。

(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 [2] 

(4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。

```java
package main.java.com.youxin.sort;

import java.util.Arrays;

/**
 * @author youxin
 * @program datas_tructure-algorithm
 * @description 快速排序算法
 * @date 2021-09-17 16:35
 */
public class QuickSort {
    public static void main(String[] args) {
        int[] array = new int[]{9,8,4,1,5,6,7,3,2,0};
        QuickSort qs = new QuickSort();
        qs.quickSort(array,0,9);
        System.out.println(Arrays.toString(array));
    }

    /**
     * @author youxin
     * @date 2021-09-17 16:51
     * @param arr
     * @param left
     * @param right
     * @return void
     * @throws 
     * @since 
     */
    public void quickSort(int[] arr,int left,int right){
        if(left >= right)
            return;
        int i = left;
        int j = right;
        int temp = arr[left];
        while (i < j) {
            while(j > i && arr[j] >= temp)//从右至左找到比temp小的第一个数
                j--;
            if(i < j){
                arr[i] = arr[j];
                i++;
            }
            while(j > i && arr[i] <= temp)//从左至右找到第一个比temp大的数
                i++;
            if(i < j){
                arr[j] = arr[i];
                j--;
            }
        }
        arr[i] = temp;//当i == j时将temp赋值给arr[i]
        quickSort(arr, left, i-1);//递归调用
        quickSort(arr, i+1, right);//递归调用
    }
}

```

![image-20210917165118260](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210917165118260.png)

### 归并排序

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218163120151-452283750.png)

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218194508761-468169540.png)

归并排序（MERGE-SORT）是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题**分**(divide)成一些小的问题然后递归求解，而**治(conquer)**的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

```java
package main.java.com.youxin.sort;

import java.util.Arrays;

/**
 * @author youxin
 * @program datas_tructure-algorithm
 * @description 归并排序算法
 * @date 2021-09-17 17:26
 */
public class MergeSort {
    public static void main(String[] args) {
        int[] array = new int[]{9,8,4,1,5,6,7,3,2,0};
        int[] temp = new int[array.length];
        MergeSort ms = new MergeSort();
        ms.mergeSort(array,0,9,temp);
        System.out.println(Arrays.toString(array));
    }

    /**
     * @author youxin
     * @date 2021-09-17 17:34
     * @param arr
     * @param left
     * @param middle
     * @param right
     * @param temp 临时数组，用来将两个数组进行合并后的临时存储数组
     * @return void
     * @throws
     * @since
     */
    public void merge(int arr[],int left,int middle,int right,int temp[]){
        int i = left;
        int m = middle;
        int j = middle+1;
        int n = right;
        int k = 0;
        while (i <= m && j <= n) {
            if(arr[i] <= arr[j]){
                temp[k] = arr[i];
                k++;
                i++;
            }else{
                temp[k] = arr[j];
                k++;
                j++;
            }
        }
        while (i <= m) {
            temp[k] = arr[i];
            k++;
            i++;
        }
        while (j <= n) {
            temp[k] = arr[j];
            k++;
            j++;
        }
        for(int c=0;c < k;c++){//将temp临时数组赋值给要排序的a数组
            arr[left+c] = temp[c];
        }
    }

    /**
     * @author youxin
     * @date 2021-09-17 17:34
     * @param arr
     * @param left
     * @param right
     * @param temp
     * @return void
     * @throws
     * @since
     */
    public void mergeSort(int arr[],int left,int right,int temp[]){
        if(left < right){
            int middle = (left + right)/2;
            mergeSort(arr, left, middle, temp);//递归调用
            mergeSort(arr, middle+1, right, temp);
            merge(arr, left, middle, right, temp);
        }
    }

}
```

![image-20210917173752706](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210917173752706.png)

### 基数排序

#### 基本思想

将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。

![img](https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif)

```java
package main.java.com.youxin.sort;

import java.util.Arrays;

/**
 * @author youxin
 * @program datas_tructure-algorithm
 * @description 基数排序算法
 * @date 2021-09-17 18:39
 */
public class RadixSort {
    public static void main(String[] args) {
        int[] array = new int[]{53,3,542,748,14,214};
        RadixSort rs = new RadixSort();
        rs.radixSort(array);
    }

    /**
     * @author youxin
     * @date 2021-09-18 10:24
     * @param arr
     * @return void
     * @throws
     * @since
     */
    private void radixSort(int[] arr) {
        //定义十个桶，每个桶就是一个一维数组
        //其中每个桶的大小是arr.length，因为不知道每个桶应该放多少个元素进去，防止溢出
        int[][] bucket = new int[10][arr.length];
        //定义一个一维数组，记录每个桶中存放元素的个数
        int[] bucketElemCounts = new int[10];

        //获取数组中的最大数
        //假定最大数为第一个数
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        //获取循环次数
        int loopNums = (max + "").length();
        //其中n用作可以循环下一位数，如先从个位到十位……
        for (int i = 1,n = 1; i <= loopNums; i++,n *= 10) {
            //往桶中存放
            for (int j = 0; j < arr.length; j++) {
                int target = arr[j] / n % 10;
                //将原数组放入到二维数组桶中
                bucket[target][bucketElemCounts[target]] = arr[j];
                bucketElemCounts[target]++;
            }

            //记录原本数组下标
            int index = 0;
            //从桶中取出
            for (int k = 0; k < bucketElemCounts.length; k++) {
                //当bucketElemCounts[k] != 0时表示该桶中有数据需要取出
                if (bucketElemCounts[k] != 0) {
                    for (int r = 0; r < bucketElemCounts[k]; r++) {
                        //将桶中数据取回到需要排序的数组中
                        arr[index] = bucket[k][r];
                        //原数组下标++
                        index++;
                    }
                    //取完后将bucketElemCounts数组进行清零
                    bucketElemCounts[k] = 0;
                }
            }
            System.out.println("这是第" + i + "次排序，这次排序后数组为:" + Arrays.toString(arr));
        }
    }
}

```

![image-20210918130019347](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210918130019347.png)

### 堆排序

1)堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。

2)堆是具有以下性质的完全二叉树:每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆,注意:没有要求结点的左孩子的值和右孩子的值的大小关系。

3)每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆

4)大顶堆举例说明

![image-20210923111848100](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210923111848100.png)

5)小顶堆举例说明

![image-20210923111949061](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210923111949061.png)

6)一般升序用大顶堆，降序采用小顶堆

#### 堆排序基本思想

1、将待排序序列构造成一个大顶堆

2、此时，整个序列的最大值就是堆顶的根节点

3、将其与末尾元素进行交换，此时末尾就为最大值

4、然后将剩余n-1个元素重新构造成一个堆，这样就会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。

可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了。

```java
package main.java.com.youxin.sort;

import java.util.Arrays;

/**
 * @author youxin
 * @program datas_tructure-algorithm
 * @description 堆排序算法
 * @date 2021-09-23 15:37
 */
public class HeapSort {
    public static void main(String[] args) {
        int[] array = new int[]{33,2,4,5,77,22222,-2,90,999};
        heapSort(array);
        System.out.println("进行堆排序后:" + Arrays.toString(array));
    }

    /**
     * @author youxin
     * @date 2021-09-23 15:57
     * @param arr
     * @return void
     * @throws
     * @since
     */
    public static void heapSort(int[] arr) {
        int temp = 0;
        //从最后一个开始循环，直到只剩一个数的时候退出循环
        for (int i = arr.length - 1; i > 0; i--) {
            //每一次需要排序成大顶堆的时候需要从下标为arr.length / 2 - 1的位置开始循环
            for (int j = arr.length / 2 - 1; j >= 0; j --) {
                //调用的时候因为i是表示下标，所以要进行 + 1操作
                adjustHeap(arr, j, i + 1);
            }
            //交换数组第一个数和最后一个数，因为此时数组中第一个数是最大的数
            temp = arr[i];
            arr[i] = arr[0];
            arr[0] = temp;
        }
    }
    /**
     * @author youxin
     * @date 2021-09-23 15:45
     * @param arr 需要排序的数组
     * @param i 从下标为 i 的位置开始进行排序
     * @param length 数组长度， 并且length 在逐渐减少
     * @return void
     * @throws
     * @since
     */
    public static void adjustHeap(int[] arr, int i, int length) {
        //临时变量存储arr[i];
        int temp = arr[i];
        //从左子节点开始遍历
        for (int k = i * 2 + 1; k < length; k = i * 2 + 1) {
            if (k + 1 < length && arr[k] < arr[k + 1]) {//如果左子节点小于右子节点，就将指针指向右子节点
                k++;
            }
            //判断左子节点和右子节点中较大的一个是否大于父节点
            if (temp < arr[k]) {
                //交换
                arr[i] = arr[k];
                //将i指向k继续比较
                i = k;
            }else {
                break;
            }
        }
        //当循环结束时，该局部二叉树中根节点就是最大值，此时要将原来最大值与根节点交换位置
        arr[i] =temp;
    }
}
```

![image-20210923162130390](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210923162130390.png)

## 查找算法

### 线性查找算法



### 二分查找算法

#### 二分查找的思路分析

1.首先确定该数组的中间的下标mid= (left+right)/ 2

2.然后让需要查找的数findval和arr[mid]比较

2.1 findVal>arr[mid]，说明你要查找的数在mid的右边,因此需要递归的向右查找

2.2 findval<arr[mid],说明你要查找的数在mid的左边,因此需要递归的向左查找

2.3 findval ==arr[mid]说明找到，就返回

//什么时候我们需要结束递归.

1)找到就结束递归

2)递归完整个数组，仍然没有找到findval，也需要结束递归当left> right就需要退出

```java
package main.java.com.youxin.search;

import java.util.ArrayList;
import java.util.List;

/**
 * @author youxin
 * @program datas_tructure-algorithm
 * @description 二分查找算法
 * @date 2021-09-18 16:17
 */
public class BinarySearch {
    public static void main(String[] args) {
        int[] array = new int[]{2,3,5,77,77,545};
        List<Integer> list = binarySearch(array, 0, 5, 77);
        if (list != null) {
            for (int elem : list) {
                System.out.printf("下标:%d\t", elem);
            }
        }else {
            System.out.println("数组中不存在该值！");
        }
    }
    
    
    /**
     * @author youxin
     * @date 2021-09-18 1
     * @param arr
     * @param left
     * @param right
     * @param findVal
     * @return java.util.List
     * @throws 
     * @since 
     */
    public static List binarySearch(int[] arr, int left, int right, int findVal){
        //判断left是<right
        if (left <= right) {
            //找到中间值
            int mid = (left + right) / 2;
            if (findVal < arr[mid]){
                //递归
                return binarySearch(arr, left, mid - 1, findVal);
            }else if (findVal > arr[mid]){
                return binarySearch(arr, mid + 1, right, findVal);
            }else{
                //创建数组存放所有跟findVal相等的值的下标
                List<Integer> indexList = new ArrayList<>();
                //向mid的左边扫描，如果找到则存入列表
                int temp = mid - 1;
                while (true){
                    if (temp < 0 || arr[temp] != findVal){//向左遍历，当左边没有跟mid值相等的数就退出循环
                        break;
                    }
                    //否则将下标放入到list中
                    indexList.add(temp);
                    temp--;
                }
                indexList.add(mid);
                //向右遍历
                temp = mid + 1;
                while (true){
                    if (temp >= arr.length || arr[temp] != findVal){//向右遍历，当右边没有跟mid值相等的数就退出循环
                        break;
                    }
                    //否则也加入list
                    indexList.add(temp);
                    temp++;
                }
                return indexList;
            }
        }else {
            return null;
        }
    }
}
```

![image-20210918173401841](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210918173401841.png)

### 插值查找算法

对于二分查找算法：

![img](https://upload-images.jianshu.io/upload_images/13754622-d9999fd33743bd31.png?imageMogr2/auto-orient/strip|imageView2/2/w/359/format/webp)

也就是说我们的mid每次都是折中的取，但是对于一些均匀分布的有序表，这样做感觉有些费时，比如找字典的时候，找a这个字母，我们肯定不会从中间开始，而是偏向于字典前面一些开始。
**插值查找**就是基于这样的思想
我们对mid进行改进

![img](https://upload-images.jianshu.io/upload_images/13754622-d854005919b271eb.png?imageMogr2/auto-orient/strip|imageView2/2/w/665/format/webp)

- key就是要查找的值
- 数组a是有序表

```java
package main.java.com.youxin.search;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @author youxin
 * @program datas_tructure-algorithm
 * @description 插值查找算法
 * @date 2021-09-18 17:52
 */
public class InsertValueSearch {
    //记录查找次数
    static int count = 0;
    public static void main(String[] args) {
        int[] array = new int[100];
        for (int i = 0; i < 100; i++){
            array[i] = i + 1;
        }

        InsertValueSearch ivs = new InsertValueSearch();
        List<Integer> list = ivs.insertValSearch(array, 0, 99, 2);
        if (list != null) {
            for (int elem : list) {
                System.out.printf("下标:%d\t", elem);
                System.out.println("\n查询了" + count + "次");
            }
        }else {
            System.out.println("数组中不存在该值！");
        }

    }

    private List insertValSearch(int[] arr, int left, int right, int findVal){
        //判断left是<right
        if (left <= right) {
            //找到中间值
            int mid = left + (right - left) * ((findVal - arr[left]) / (arr[right] - arr[left]));
            if (findVal < arr[mid]){
                count++;
                return insertValSearch(arr, left, mid - 1, findVal);
            }else if (findVal > arr[mid]){
                count++;
                return insertValSearch(arr, mid + 1, right, findVal);
            }else{
                //创建数组存放所有跟findVal相等的值的下标
                List<Integer> indexList = new ArrayList<>();
                //向mid的左边扫描，如果找到则存入列表
                int temp = mid - 1;
                while (true){
                    if (temp < 0 || arr[temp] != findVal){//向左遍历，当左边没有跟mid值相等的数就退出循环
                        break;
                    }
                    //否则将下标放入到list中
                    indexList.add(temp);
                    temp--;
                }
                indexList.add(mid);
                //向右遍历
                temp = mid + 1;
                while (true){
                    if (temp >= arr.length || arr[temp] != findVal){//向右遍历，当右边没有跟mid值相等的数就退出循环
                        break;
                    }
                    //否则也加入list
                    indexList.add(temp);
                    temp++;
                }
                return indexList;
            }
        }else {
            return null;
        }
    }
}
```

![image-20210918182608462](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210918182608462.png)

### 斐波那契（黄金分割法）查找算法

## 哈希表（数据结构）

![img](https://bkimg.cdn.bcebos.com/pic/c9fcc3cec3fdfc035f8e2b9cd63f8794a4c22624?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto)

散列表（Hash table，也叫哈希表）,是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

![image-20210919153504181](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210919153504181.png)

##### 例题：

某公司，当有新员工来报到，要求将该员工的信息加入（id,name,phoneNum），当输入该员工的id时，要求查找到该员工的所有信息

**要求：**不适用数据库，尽量节省内存，速度越快越好==> 哈希表（散列表）

```java
package main.java.com.youxin.hashtable;

import java.util.Scanner;

/**
 * @author youxin
 * @program datas_tructure-algorithm
 * @description 哈希表数据结构模拟员工表
 * @date 2021-09-19 16:25
 */
public class HashTableDemo {
    public static void main(String[] args) {
        //创建哈希表
        HashTable hashTable = new HashTable(7);

        //写一个简单菜单
        String key = "";
        Scanner scanner = new Scanner(System.in);
        while (true) {
            System.out.println("add : 添加雇员");
            System.out.println("list : 遍历雇员");
            System.out.println("exit : 退出系统");
            System.out.println("delete : 删除雇员");
            key = scanner.next();
            switch (key){
                case "add" :
                    System.out.println("输入id:");
                    int id = scanner.nextInt();
                    System.out.println("输入名字:");
                    String name = scanner.next();
                    System.out.println("输入电话号码:");
                    String phoneNum = scanner.next();
                    //创建雇员
                    Emp emp = new Emp(id, name, phoneNum);
                    hashTable.add(emp);
                    break;
                case "list" :
                    hashTable.selectAll();
                    break;
                case "delete":
                    System.out.println("输入需要删除的员工id:");
                    int delId = scanner.nextInt();
                    hashTable.delete(delId);
                    break;
                case "exit" :
                    scanner.close();
                    System.exit(0);
                    break;
                default :
                    break;
            }
        }
    }

}

class HashTable{
    private EmpLinkedList[] empLinkedLists;
    private int size;

    public HashTable(int size) {
        this.size = size;
        //初始化empLinkedLists
        this.empLinkedLists = new EmpLinkedList[size];
        //并且要初始化每一条链表，如果不初始化链表，则会出现空指针异常
        for (int i = 0; i < size; i++) {
            empLinkedLists[i] = new EmpLinkedList();
        }
    }

    //添加
    public void add(Emp emp){
        empLinkedLists[getListNum(emp.getId())].addEmp(emp);
    }

    //遍历
    public void selectAll(){
        for (int i = 0; i < size; i++){
            empLinkedLists[i].list(i);
        }
    }

    //删除
    public void delete(int id) {
        empLinkedLists[getListNum(id)].del(id);
    }

    //获取是在第几个链表上操作
    public int getListNum(int id){
        return id % size;
    }

}

class Emp{
    private int id;
    private String name;
    private String phoneNum;
    private Emp next;//指向下一个emp，默认为空

    public Emp(int id, String name, String phoneNum) {
        super();
        this.id = id;
        this.name = name;
        this.phoneNum = phoneNum;
    }

    public Emp() {
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPhoneNum() {
        return phoneNum;
    }

    public void setPhoneNum(String phoneNum) {
        this.phoneNum = phoneNum;
    }

    public Emp getNext() {
        return next;
    }

    public void setNext(Emp next) {
        this.next = next;
    }
}

class EmpLinkedList{
    private Emp head;//emp指针，默认为null

    public Emp getHead() {
        return head;
    }

    public void setHead(Emp head) {
        this.head = head;
    }

    public void addEmp(Emp emp){
        if (this.getHead() == null){//表示链表为空
            head = new Emp();
//            head = emp;
            head.setNext(emp);
            return;
        }
        Emp tempEmp = this.getHead();
        while (true){//链表不为空，则插入到该链表最后
            if (tempEmp.getNext() == null){//查找到链表最后一个位置，保存并退出
                break;
            }
            tempEmp = tempEmp.getNext();//没有到最后一个位置，则继续向下遍历
        }
        //退出时将emp加入链表
        tempEmp.setNext(emp);
    }

    public void list(int num){
        if (this.getHead() == null){
            System.out.println("第" + num + "条链表为空！");
            return;
        }
        System.out.print("第" + num + "链表信息为:");
        Emp tempEmp = this.getHead();//辅助指针
        while (true) {
            System.out.printf("==> id : %d ~~ name : %s ~~ PhoneNumber : %s\t",tempEmp.getId(),tempEmp.getName(),tempEmp.getPhoneNum());
            if (tempEmp.getNext() == null){//说明已经tempEmp已经是最后的节点
                break;
            }
            //不是最后的节点，指针后移
            tempEmp = tempEmp.getNext();
        }
        //输出完后换行
        System.out.println();
    }

    public void del(int id){
        if (this.getHead() == null){
            System.out.println("链表为空，不能够删除！");
            return;
        }
        //辅助指针
        Emp tempEmp = this.getHead();
        while (true) {
            if (tempEmp.getNext() == null){//如果已经到最后一个节点
                System.out.println("链表中不存在该数据，不能够删除！");
                break;
            }else if (tempEmp.getNext().getId() == id && tempEmp.getNext().getNext() != null) { // 找到对应的节点的上一节点且对应节点不是最后一个节点
//                System.out.println("不是最后一个节点");
                //进行删除
                tempEmp.setNext(tempEmp.getNext().getNext());
                break;
            }else if (tempEmp.getNext().getId() == id && tempEmp.getNext().getNext() == null) { //找到对应的节点的上一节点且对应节点是最后一个节点
//                System.out.println("最后一个节点");
                //找到的点是最后一个节点，则将前一个节点的next置为null
                tempEmp.setNext(null);
                break;
            }else
                //不是最后节点，指针后移
            tempEmp = tempEmp.getNext();
        }
    }
}
```

## 树       

### 数的基本概念

| **术语** | **中文** |                             描述                             |
| :------: | :------: | :----------------------------------------------------------: |
|   Root   |  根节点  |                   The top node in a tree.                    |
|  Child   |  子节点  | A node directly connected to another node when moving away from the Root. |
|   Leaf   | 叶子节点 |                   A node with no children                    |
|   Edge   |    边    |         The connection between one node and another.         |
|   Path   |   路径   | A sequence of nodes and edges connecting a node with a descendant. |
|  Height  | 节点高度 | The height of a node is the number of edges on the longest path between that node and a leaf. |
|  Level   |   层级   | The level of a node is defined by 1 + (the number of connections between the node and the root). |
|  Depth   |   深度   | The depth of a node is the number of edges from the tree’s root node to the node. |
|  Degree  |    度    |              The number of subtrees of a node.               |



### 二叉树

二叉树的概念：

1）树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树

2）二叉树的子节点分为左节点和有节点

3）如果该二叉树的所有子节点都在最后一层，并且节点总数=2^n^-1，n为层数，称之为满二叉树

![image-20210920145802252](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210920145802252.png)

4）如果该二叉树的所有叶子结点都在最后一层或者倒数第二层，而且最后一层的叶子结点在左边连续不中断，倒数第二层的叶子结点在右边连续，我们称之为完全二叉树。

![image-20210920145938238](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210920145938238.png)

### 顺序存储二叉树

**概念：** 从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，如示意图。

要求:

1) 如图的二叉树的结点，要求以数组的方式来存放arr: [1,2,3,4,5,6,6]2)

2) 要求在遍历数组arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历

![image-20210922131938547](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210922131938547.png)

顺序存储二叉树的特点：

1、顺序二叉树通常只考虑完全二叉树

2、第n个元素的左子节点为2*n+1

3、第n个元素的右子节点为2*n+2

4、第n个元素的父节点为(n-1)/2

5、n:表示二叉树中的第几个元素按0开始编号



```java
package main.java.com.youxin.tree;

/**
 * @author youxin
 * @program datas_tructure-algorithm
 * @description 顺序存储二叉树
 * @date 2021-09-22 15:11
 */
public class ArrayBinaryTree {
    public static void main(String[] args) {
        int[] array = {1,2,3,4,5,6,7};
        ArrBinaryTree arrBinaryTree = new ArrBinaryTree(array);
        arrBinaryTree.preOrder();
    }
}

class ArrBinaryTree{
    private int[] arr;

    public ArrBinaryTree(int[] arr) {
        this.arr = arr;
    }

    private void preOrder(int index){
        //判断数组是否为空
        if (arr == null || arr.length == 0) {
            System.out.println("数组为空，不能对其前序遍历！");
            return;
        }
        System.out.printf("%d\t",arr[index]);
        //向左递归
        //判断向左递归的时候是否越界
        if ( (2 * index + 1) < arr.length){
            preOrder(2 * index + 1);
        }
        //向右递归
        if ((2 * index + 2) < arr.length) {
            preOrder(2 * index + 2);
        }
    }

    //重载preOrder
    public void preOrder() {
        preOrder(0);
    }

}
```

![image-20210922154254247](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210922154254247.png)

### 线索二叉树

1) n个结点的二叉链表中含有n+1【公式2n-(n-1)=n+1】个空指针域。利用二叉链表中的空指针域，存放指向结点在某种遍历次序下的前驱和后继结点的指针(这种附加的指针称为"线索")

2) 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种

3) 一个结点的前一个结点，称为前驱结点

4) 一个结点的后一个结点，称为后继结点

![image-20210922163643341](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210922163643341.png)

### 赫夫曼树

#### 基本介绍

1、给定n个权值作为n个叶子结点，构造一颗二叉树，若该数的带权路径长度（wpl）达到最小，这样的二叉树称为最优二叉树，也称为赫夫曼树。

2、赫夫曼树是带权路径长度最短的数，权值较大的节点离根较近。

### 重要概念

1）路径和路径长度:在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1

2)结点的权及带权路径长度:若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为:从根结点到该结点之间的路径长度与该结点的权的乘积

3)树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length)，权值越大的结点离根结点越近的二叉树才是最优二叉树。

4)WPL最小的就是赫夫曼树

![image-20210923165401572](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210923165401572.png)

### 构成赫夫曼树的步骤

1)从小到大进行排序,将每一个数据，每个数据都是一个节点,每个节点可以看成是一颗最简单的二叉树

2)取出根节点权值最小的两颗二叉树

3)组成―颗新的二叉树,该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和

4)再将这颗新的二叉树，以根节点的权值大小再次排序,不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树

```java
package main.java.com.youxin.tree;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @author youxin
 * @program datas_tructure-algorithm
 * @description 生成赫夫曼树
 * @date 2021-09-24 10:29
 */
public class HuffmanTree {
    public static void main(String[] args) {
        int[] array = new int[]{23, 5, 3, 6, 66, 13, 17};
        selectAll(creatHuffmanTree(array));
    }

    //创建赫夫曼树
    public static Node creatHuffmanTree(int[] arr) {
        List<Node> nodeList = new ArrayList<Node>();
        //将arr存放进链表中
        for (int i = 0; i < arr.length; i++) {
            nodeList.add(new Node(arr[i]));
        }
        while (nodeList.size() > 1) {
            //排序
            Collections.sort(nodeList);

            //取出权值最小的两个节点作为左子节点和右子节点
            Node leftNode = nodeList.get(0);
            Node rightNode = nodeList.get(1);
            //创建父节点，并将左子节点和右子节点给父节点
            Node fatherNode = new Node(nodeList.get(0).value + nodeList.get(1).value);
            fatherNode.left = leftNode;
            fatherNode.right = rightNode;

            //删除前两个节点并将父节点添加到节点中
            nodeList.remove(0);
            nodeList.remove(0);
            nodeList.add(fatherNode);
        }
        return nodeList.get(0);
    }

    //遍历树
    /**
     * @param root 根节点
     * @return void
     * @throws
     * @author youxin
     * @date 2021-09-24 16:53
     * @since
     */
    public static void selectAll(Node root) {
        if (root != null) {
            System.out.println("前序遍历");
            root.preOrder();
        } else
            System.out.println("空树，不能遍历！");
    }
}

class Node implements Comparable<Node> {
    //节点中存放的值
    int value;
    //左子节点
    Node left;
    //右子节点
    Node right;

    //前序遍历
    public void preOrder() {
        System.out.println(this);
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    public Node(int value) {
        this.value = value;
    }

    //重写toString
    @Override
    public String toString() {
        return "node:  [value=" + value + "]";
    }

    @Override
    public int compareTo(Node o) {
        return this.value - o.value;
    }
}
```

![image-20210924165625556](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210924165625556.png)

### 赫夫曼编码

#### 基本介绍

1)赫夫曼编码也翻译为哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式,属于一种程序算法。

2)赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。

3)赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%~90%之间。

4)赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码。

#### 原理剖析

1、通信领域中信息的处理方式1-定长编码

i like like like java do you like a java      //共40个字符(包括空格)

105 32108 105 107 101 32108 105107101 32108105 107101 32106 97 1189732100111 32121111117 32108 1051101 32 9732106 9711897 lI对应Ascii码

011010010010000001101100011010010110101101100101001000000110110001101001011010110110010100100000011011000110100101101011011001010010000001101010011000010111011001100001 00100000011001000110111100100000 01111001011011110111010100100000 011011000110100101101011011001010010000001100001 00100000 01101010011000010111011001100001 11对应的二进制

按照二进制来传递信息，总的长度是359(包括空格)

2、通信领域中信息的处理方式2-变长编码

i like like like java do you like a java    //共40个字符(包括空格)

d:1 y:1 u:1 j;2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9    //各个字符对应的个数

0= ，1=a,10=i,11=e,100=k,101=l,110=o,111=v,1000=j,1001=u,1010=y,1011=d说明:按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如空格出现了9次，编码为0 ,其它依次类推.

按照上面给各个字符规定的编码，则我们在传输"i like like like java do you like a java"数据时，编码就是10010110100...

字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码，即不能匹配到重复的编码

3、通信领域中信息的处理方式3-赫夫曼编码

i like like like java do you like a java      //共40个字符(包括空格)

d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9各个字符对应的个数按照上面字符出现的次数构建一颗赫夫曼树,次数作为权值.

##### 构成赫夫曼树的步骤:

1)从小到大进行排序,将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单的二叉树

2)取出根节点权值最小的两颗二叉树

3)组成一颗新的二叉树,该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和

4)再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树

![image-20210925150039184](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210925150039184.png)

5)根据赫夫曼树，给各个字符,规定编码(前缀编码)，向左的路径为O向右的路径为1，编码如下: o:1000 u: 10010 d: 100110 y: 100111 i: 101

 a : 110k: 1110 e: 1111 j:0000 v: 0001 l: 001  空格 :01

6)按照上面的赫夫曼编码，我们的"i like like like java do you like a java”字符串对应的编码为(注意这里我们使用的无损压缩)

1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110通过赫夫曼编码处理长度为133

7)长度为:133

**说明:**

原来长度是359,压缩了(359-133)/359=62.9%

此编码满足前缀编码,即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性赫夫曼编码是无损处理方案。

```java
package main.java.com.youxin.huffman;

import java.util.*;

/**
 * @author youxin
 * @program datas_tructure-algorithm
 * @description 赫夫曼编码算法
 * @date 2021-09-25 15:56
 */
public class HuffmanCode {
    public static void main(String[] args) {
        String string = "i like like like java do you like a java";
        System.out.println("需要压缩的字符串：" + string);
/*        byte[] bytes = string.getBytes();
        Node root = creatHuffmanTree(bytesToList(bytes));
        preOrder(root);

//        toHuffmanCodes(root, "", sb);
        System.out.println("huffmanCodes:" + toHuffmanCodes(root));
        System.out.println("bytes[] = " + Arrays.toString(toZip(bytes, huffmanCodes)));
//        toZipHuffmanCodes(string);*/
        byte[] bytes = toZipHuffmanCodes(string);
        System.out.println("将原来数组进行赫夫曼编码后需要传输的byte数组:" + Arrays.toString(bytes));
        StringBuilder toBitString = bytesToBitString(bytes);
        System.out.println("将byte数组转为为赫夫曼编码:" + toBitString);
        String source = decode(huffmanCodes, toBitString);
        System.out.println("将赫夫曼编码解码后:" + source);
    }


    //将压缩后的byte[]转成二进制字符串
    public static StringBuilder bytesToBitString(byte[] bytes) {
        StringBuilder stringBuilder = new StringBuilder();
        //保存变量bytes
        for (int i = 0; i < bytes.length; i++) {
            int temp = bytes[i];
            if (i != bytes.length - 1) {
                temp |= 256;
            }
            String string = Integer.toBinaryString(temp);
            if (i != bytes.length - 1) {
                stringBuilder.append(string.substring(string.length() - 8));
            } else {
                stringBuilder.append(string);
            }
//            System.out.println(stringBuilder);
        }
//        System.out.println(stringBuilder.length());
        return stringBuilder;
    }

    /**
     * @param huffmanCodes  赫夫曼树构建的赫夫曼编码map
     * @param stringBuilder 需要解码的赫夫曼编码
     * @return java.lang.String 解码后的string
     * @throws
     * @author youxin
     * @date 2021-09-26 16:55
     * @since
     */
    public static String decode(Map<Byte, String> huffmanCodes, StringBuilder stringBuilder) {
        Map<String, Byte> map = new HashMap<String, Byte>();
        //将赫夫曼编码的键值对调换位置
        for (Map.Entry<Byte, String> entry : huffmanCodes.entrySet()) {
            map.put(entry.getValue(), entry.getKey());
        }
        //存放解码后的byte
        List<Byte> list = new ArrayList<Byte>();
        //存放需要判断的key

        int count = 1;
        for (int i = 0; i < stringBuilder.length(); ) {
            Byte b = null;
            //截取操作
            String substring = stringBuilder.substring(i, i + count);
            b = map.get(substring);
            if (b == null) {
                //匹配不到对应的key，继续循环得到string
                count++;
            } else {
                //如果在map中存在b为key,则将对应的value存入到list中
                list.add(b);
                //调整i的值
                i += count;
                //调整完i的值后重新赋值count
                count = 1;
            }
        }
        byte[] bytes = new byte[list.size()];
        //将list全部放入到byte数组中
        for (int i = 0; i < list.size(); i++) {
            bytes[i] = list.get(i);
        }
        //将byte数组转为string并返回
        return new String(bytes);

    }

    //封装方法

    /**
     * @param str 需要压缩的字符串
     * @return byte[] 返回压缩后的byte数组
     * @throws
     * @author youxin
     * @date 2021-09-26 14:50
     * @since
     */
    public static byte[] toZipHuffmanCodes(String str) {
        toHuffmanCodes(creatHuffmanTree(bytesToList(str.getBytes())));
        byte[] bytes = toZip(str.getBytes(), huffmanCodes);
        return bytes;
    }

    /**
     * @param nodes 将传递的nodes用来创建赫夫曼树
     * @return main.java.com.youxin.huffman.Node
     * @throws
     * @author youxin
     * @date 2021-09-25 19:01
     * @since
     */
    public static Node creatHuffmanTree(List<Node> nodes) {
        while (nodes.size() > 1) {
            //排序
            Collections.sort(nodes);
            //获取左子节点
            Node leftNode = nodes.get(0);
            //获取右子节点
            Node rightNode = nodes.get(1);
            //合成父节点
            Node fatherNode = new Node(null, leftNode.weight + rightNode.weight);
            //加入父节点
            fatherNode.left = leftNode;
            fatherNode.right = rightNode;
            //在list中删除两个最小的子节点
            nodes.remove(leftNode);
            //或
            //nodes.remove(0);
            //说明:因为前面已经删除了一个最小的节点，所以后面的节点下标自动前移，所以删除第二小的节点还是删除下标为0的节点
            nodes.remove(0);
            //添加父节点
            nodes.add(fatherNode);
        }
        return nodes.get(0);
    }

    //将byte数组转换为list
    public static List<Node> bytesToList(byte[] bytes) {
        //创建一个list
        List<Node> nodes = new ArrayList<Node>();
        //遍历bytes,统计每个字符出现的次数 => map
        Map<Byte, Integer> maps = new HashMap<>();
        for (byte b : bytes) {
            //存放字符出现的次数
            Integer counts = maps.get(b);
            if (counts == null) {//现在map中还没有该字符数据
                maps.put(b, 1);
            } else {//该字符已经存在
                maps.put(b, ++counts);
            }
        }
        //把每个键值对转成一个node对象并加入集合
        //遍历map
        for (Map.Entry<Byte, Integer> entry : maps.entrySet()) {
            nodes.add(new Node(entry.getKey(), entry.getValue()));
        }
        return nodes;
    }

    //前序遍历方法
    public static void preOrder(Node root) {
        if (root == null) {
            System.out.println("树为空，不能前序遍历！");
        } else {
            root.preOrder();
        }
    }

    //将生成的赫夫曼树生成对应的赫夫曼编码
    //将赫夫曼编码存放在Map形式中
    static Map<Byte, String> huffmanCodes = new HashMap<>();
    //用StringBuilder用来拼接路径，存储某个叶子结点的路径
    static StringBuilder sb = new StringBuilder();

    /**
     * @param node 需要处理的节点
     * @param code 节点路径，0表示向左，1表示向右
     * @param sb   路径编码
     * @return void
     * @throws
     * @author youxin
     * @date 2021-09-25 17:29
     * @since
     */
    public static void toHuffmanCodes(Node node, String code, StringBuilder sb) {
        StringBuilder sb_2 = new StringBuilder(sb);
        //将code加入到sb_2中
        sb_2.append(code);
        if (node != null) {//如果node为空则不处理
            //判断当前节点是叶子结点还是非叶子结点
            if (node.data == null) {//非叶子结点
                //向左递归
                toHuffmanCodes(node.left, "0", sb_2);
                //向右递归
                toHuffmanCodes(node.right, "1", sb_2);
            } else {//叶子结点
                huffmanCodes.put(node.data, sb_2.toString());
            }
        }
    }

    //重载，目的是调用更加简洁
    public static Map<Byte, String> toHuffmanCodes(Node root) {
        if (root == null) {
            System.out.println("为空，不能处理！");
            return null;
        }
        toHuffmanCodes(root, "", sb);
        return huffmanCodes;
    }

    /**
     * @param bytes        需要转为数组的bytes
     * @param huffmanCodes 传递的是前面已经生成的赫夫曼编码map 对象
     * @return byte[]
     * @throws
     * @author youxin
     * @date 2021-09-25 18:59
     * @since
     */
    public static byte[] toZip(byte[] bytes, Map<Byte, String> huffmanCodes) {
        StringBuilder stringBuilder = new StringBuilder();
        //遍历bytes，并在huffmanCodes的map中找到对应的value并添加
        for (byte b : bytes) {
            stringBuilder.append(huffmanCodes.get(b));
        }
        System.out.println("将原来的字符串转化为赫夫曼编码stringBuilder:" + stringBuilder);
        //将stringBuilder转为byte[]
        int bytesLen = (stringBuilder.length() + 7) / 8;
        byte[] bytes1 = new byte[bytesLen];
        int index = 0;
        for (int i = 0; i < stringBuilder.length(); i += 8) {
            String stringByte;
            if ((i + 8) > stringBuilder.length()) {
                //如果i + 8 大于了stringBuilder.length()，则将最后不满8位的数字转成stringByte
                stringByte = stringBuilder.substring(i);
            } else {
                stringByte = stringBuilder.substring(i, i + 8);
            }
            //将获取的每八位byte转成byte传入byte[]中
//            System.out.println(stringByte);
            bytes1[index++] = (byte) Integer.parseInt(stringByte, 2);
//            System.out.println(bytes1[index]);
        }
        return bytes1;
    }
}

class Node implements Comparable<Node> {
    Byte data;//存放字符本身
    int weight;//权重，存放该字符出现的次数
    Node left;//左子节点
    Node right;//右子节点

    public Node(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    @Override
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                '}';
    }

    //由小到大排序
    //想要逆序return -(this.weight - o.weight);
    @Override
    public int compareTo(Node o) {
        return this.weight - o.weight;
    }

    //前序遍历
    public void preOrder() {
        System.out.println(this);
        if (this.left != null) {
            left.preOrder();
        }
        if (this.right != null) {
            right.preOrder();
        }
    }
}

```

![image-20210926170150021](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210926170150021.png)

### 二叉排序树

#### 介绍

二叉排序树:BST: (Binary Sort(Search)Tree),对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。

特别说明:如果有相同的值，可以将该节点放在左子节点或右子节点比如针对前面的数据(7,3,10,12,5,1,9)，对应的二叉排序树为:

![image-20210927145850569](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210927145850569.png)

```java
package main.java.com.youxin.binarysorttree;

/**
 * @author youxin
 * @program datas_tructure-algorithm
 * @description 二叉排序树数据结构
 * @date 2021-09-27 15:19
 */
public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7, 3, 10, 12, 5, 1, 9};
        BinaryOrderTree binaryOrderTree = new BinaryOrderTree();
        for (int i = 0; i < arr.length; i++) {
            binaryOrderTree.add(new Node(arr[i]));
        }

        //中序遍历
        System.out.println("对该二叉排序树进行中序遍历:");
        binaryOrderTree.inOrder();

    }
}

//创建二叉排序树
class BinaryOrderTree {
    private Node root;
    public void add(Node node) {
        if (root == null) {
            root = node;
        }else {
            root.add(node);
        }
    }

    public void inOrder() {
        if (root != null) {
            root.inOrder(root);
        }else {
            System.out.println("二叉排序树为空，不能遍历！");
        }
    }
}

class Node{
    public int value;
    public Node left;
    public Node right;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    public void add(Node node) {
        if (node == null) {
            System.out.println("不能插入空节点！");
            return;
        }else {
            //如果待插入的节点的value小于或等于当前节点
            if (node.value <= this.value) {
                //如果当前节点的左子树为空，则直接插入
                if (this.left == null) {
                    this.left = node;
                } else {
                    this.left.add(node);
                }
            } else {//如果待插入的节点大于当前节点
              if (this.right == null) {
                  this.right = node;
              }else {
                  this.right.add(node);
              }
            }
        }
    }

    //中序遍历
    public void inOrder(Node root) {

        if (root.left != null) {
            root.left.inOrder(root.left);
        }
        System.out.println(root);
        if (root.right != null) {
            root.right.inOrder(root.right);
        }
    }
}

```

![image-20210927174103898](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210927174103898.png)

### 平衡二叉树（AVL树）

#### 基本介绍

1）平衡二叉树也叫平衡二叉搜索树(Self-balancing binary search tree）又被称为AVL树，可以保证查询效率较高。

2)具有以下特点:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。

#### 处理--进行左旋转

1、创建一个新的节点newNode，值等于当前根节点的值 

//把新节点的左子树设置成当前节点的左子树

2、newNode.left = left

//把新节点的右子树设置为当前节点的右子树的左子树

3、newNode.right = right.left

//把当前节点的值换为右子节点的值

4、value = right.value

//把当前节点的右子树设置成右子树的右子树

5、right = right.right

//把当前节点的左子树设置为新节点

6、left = newLeft

![image-20210927183559090](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210927183559090.png)

问题：如果左子树的右子树（左子树）高度大于左子树（右子树）高度，则对其进行左旋转或右旋转还是不能构成平衡二叉树

![image-20210927184617057](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210927184617057.png)

这时需要先对当前节点的左节点进行左旋转，然后再对当前节点进行右旋转即可

### 多叉树

在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更对的子节点，就是多叉树。

![image-20210928153132405](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210928153132405.png)

#### 2-3树

2-3树是最简单的B树结构，具有如下几个特点：

1)2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)

2)有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点，

3)有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.

4)2-3树是由二节点和三节点构成的树。

![image-20210928155410283](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210928155410283.png)

#### B树

B-tree树即B树，B即Balanced，平衡的意思。

##### 介绍

前面已经介绍了2-3树和2-3-4树，他们就是B树(英语:B-tree也写成B-树)，这里我们再做一个说明，我们在学习Mysql时，经常听到说某种类型的索引是基于B树或者B+树的，如图:

![image-20210928155539138](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210928155539138.png)

##### B树的说明：

1)B树的阶:节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4

2)B-树的搜索，从根结点开始，对结点内的关键字(有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点;重复，直到所对应的儿子指针为空，或已经是叶子结点

3)关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据.

4)搜索有可能在非叶子结点结束

5)其搜索性能等价于在关键字全集内做一次二分查找

#### B+树

##### 介绍

B+树是B树的变体，也是一种多路搜索树

![image-20210928160123888](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210928160123888.png)

##### 说明

1)B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找

2)所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】)，且链表中的关键字(数据)恰好是有序的。

3)不可能在非叶子结点命中

4)非叶子结点相当于是叶子结点的索引(稀疏索引),叶子结点相当于是存储(关键宁）数据的数据层5)更适合文件索引系统

6)B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.

#### B*树

##### 介绍

B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。

![image-20210928161024326](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210928161024326.png)

##### B*树的说明:

1)B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。

2)从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高

## 图

### 图的常用概念

![image-20210928162850867](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210928162850867.png)

![image-20210928163228970](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210928163228970.png)

### 图的表示方式

图的表示方式有两种：二维数组表示（邻接矩阵），链表表示（邻接表）

#### 领接矩阵

邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵的row和col表示的是1...n个点

![image-20210928164114910](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210928164114910.png)

#### 邻接表

1、邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失.

2、邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成

![image-20210928164210614](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210928164210614.png)

### 图的代码实现

```java
package main.java.com.youxin.graph;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @author youxin
 * @program datas_tructure-algorithm
 * @description 图的数据结构的实现
 * @date 2021-09-28 17:13
 */
public class Graph {

    public static void main(String[] args) {
        //定义节点个数
        int n = 5;

        String[] vertexValues = {"A","B","C","D","E"};
        //创建图对象
        Graph graph = new Graph(n);
        //添加节点
        for (String vertexValue: vertexValues
             ) {
            graph.insertVertex(vertexValue);
        }
        //添加边
        graph.insertEdges(0, 1, 1);
        graph.insertEdges(0, 2, 1);
        graph.insertEdges(1, 2, 1);
        graph.insertEdges(1, 3, 1);
        graph.insertEdges(1, 4, 1);
        //显示
        graph.showGraph();
    }

    public List<String> vertexList;
    public int[][] edges;
    public int numOfEdges;

    public Graph(int n) {
        edges = new int[n][n];
        vertexList = new ArrayList<String>();
        numOfEdges = 0;
    }

    //插入节点
    public void insertVertex(String vertex) {
        vertexList.add(vertex);
    }

    //添加边
    public void insertEdges(int v1, int v2, int weight){
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }

    //图中常用的方法
    //返回节点的个数
    public int getNumOfVertexs() {
        return vertexList.size();
    }

    //得到边的个数
    public int getNumOfEdges(){
        return numOfEdges;
    }

    //返回节点i(下标)对应的数据
    public String valueByIndex(int index) {
        return vertexList.get(index);
    }

    //返回v1,v2的权值
    public int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }

    //显示图对应的矩阵
    public void showGraph() {
        for (int[] row : edges) {
            System.out.println(Arrays.toString(row));
        }
    }
}

```

![image-20210928174004835](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210928174004835.png)

### 图的深度优先遍历

1)深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点，可以这样理解:每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。

2)我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。

3)显然，深度优先搜索是一个递归的过程

#### 深度优先遍历算法步骤

1访问初始结点v，并标记结点v为已访问。

2)查找结点v的第一个邻接结点w.

3)若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。

4)若w未被访问，对w进行深度优先遍历递归〈即把w当做另一个v，然后进行步骤123）。

5)查找结点v的w邻接结点的下一个邻接结点，转到步骤3。

### 图的广度优先遍历

#### 基本思想

图的广度优先搜索(Broad First Search).

类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点

#### 广度优先遍历算法步骤

1)访问初始结点v并标记结点v为己访问。

2)结点v入队列

3)当队列非空时,继续执行，否则算法结束。

4)出队列,取得队头结点u。

5)查找结点u的第一个邻接结点w。

6)若结点u的邻接结点w不存在，则转到步骤3;否则循环执行以下三个步骤:6.1若结点w尚未被访问，则访问结点w并标记为已访问。

6.2结点w入队列

6.3查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。

